# ===============================================================================
# Copyright 2019 Jan Hendrickx and Gabriel Parrish
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ===============================================================================
import pandas as pd
# ============= standard library imports ========================
from utils.TAW_optimization_subroutine.timeseries_processor import accumulator
from utils.ameriflux_swhc_calibration.ameriflux_etrm_swhc_calibration import get_chisquare_dict, taw_optimize_1d

"""This script will perform the calibration based on files generated by data_extract_by_TAW.py"""


# =============== Specify the TYPE of Calibration ============
# unless true we do the default, which is to run calibration agains eta which can be cumulative
rzsm = True

# If calibrating to ETa, i.e rzsm=False, an interger of the number of days to accumulate.
cum_int = 14

# =============== Specify the output_path ============
outpath = '/Users/dcadol/Desktop/academic_docs_II/calibration_approach/mini_model_outputs/mpj/calibration_output'
amf_name = 'US-Mpj'

# =========Modify Dates==============
# Specify the growing season
start_grow_month = 5
start_grow_day = 15

end_grow_month = 9
end_grow_day = 15
growing_season = ((5, 15), (9, 15))

# starting TAW value
begin_taw = 25
# ending TAW value
end_taw = 925
# grid search step size. Each ETRM run will increase the uniform TAW of the RZSW holding capacity by this many mm.
taw_step = 25
# ==================================

data_path = '/Users/dcadol/Desktop/academic_docs_II/calibration_approach/mini_model_outputs/mpj/taw_{}_dataset.csv'

taw_list = []
optimization_dict = {}
for i in range(0, ((end_taw - begin_taw) / taw_step)):
    if i == 0:
        current_taw = begin_taw
    else:
        current_taw += taw_step

    taw_list.append(current_taw)
    data_df = pd.read_csv(data_path.format(current_taw), parse_dates=True, index_col=0)

    timeseries = data_df.index.values

    if rzsm:
        # get rid of Nan Values for both datasets
        data_df = data_df[data_df['average_vals_rzsm'].notnull()]
        data_df = data_df[data_df['nrml_depth_avg_sm'].notnull()]

        # get rid of the zero values
        data_df[data_df['average_vals_rzsm'] == 0] = 0.0001
        data_df[data_df['nrml_depth_avg_sm'] == 0] = 0.0001

        print 'month range {}'.format(range(5, 9))
        data_df = data_df[data_df.index.month.isin(range(5, 9))]



        # Observed normalized rzsm fraction
        obs_rzsm = data_df['nrml_depth_avg_sm']
        # # if you don't normalize, you don't get a minimum in the validation curve.
        # obs_rzsm = data_df['depth_avg_sm']

        # ETRM modeled normalized rzsm fraction
        model_rzsm = data_df['average_vals_rzsm']

        optimization_dict['{}'.format(current_taw)] = (model_rzsm, timeseries, obs_rzsm)

    else:

        # get rid of Nan Values for both datasets
        data_df = data_df[data_df['average_vals_eta'].notnull()]
        data_df = data_df[data_df['amf_eta_values'].notnull()]

        # TODO - filter out non-growing season dates [What is a better way to do this so i can get late may to mid september of each year]
        # WITHOUT hard coding it.
        print 'month range {}'.format(range(5, 9))
        data_df = data_df[data_df.index.month.isin(range(5, 9))]

        data_df = accumulator(time_df=data_df, time_unit='days', cum_int=cum_int)

        # get rid of the zero values # TODO - be mindful that this does not cause issues when eta is zero at spinup or low TAW vals.
        # data_df = data_df[data_df['average_vals_eta'] != 0]
        # data_df = data_df[data_df['amf_eta_values'] != 0]
        data_df[data_df['average_vals_eta'] == 0] = 0.0001
        data_df[data_df['amf_eta_values'] == 0] = 0.0001

        data_df.to_csv('/Users/dcadol/Desktop/cum_model_df_{}.csv'.format(current_taw))

        # Observed ETa
        obs_eta = data_df['amf_eta_values']
        # Modeled ETa
        model_eta = data_df['average_vals_eta']
        # Cumulative_time
        cum_dates = data_df.index.values

        optimization_dict['{}'.format(current_taw)] = (model_eta, cum_dates, obs_eta)


# if rzsm is false we want it to be cumulative mode.
cumulative_mode = not rzsm

if cumulative_mode:
    name_ext = '_cum'
else:
    name_ext = '_non_cum'

if not rzsm:
    # for ameriflux
    estimated_observational_error = 0.3
elif rzsm:
    # TODO - What is the corect observational error?
    estimated_observational_error = 0.4
chi_dictionary, dof_dict = get_chisquare_dict(model_dictionary=optimization_dict, parameter_lst=taw_list,
                                              percent_error=estimated_observational_error,
                                              outpath=outpath, name=amf_name, cum_mode=cumulative_mode, rzsm=rzsm)

# get the number of observations out
dof = dof_dict['{}'.format(taw_list[0])]

print 'generating chimin dictionary'
chimin_dict = taw_optimize_1d(parameter_lst=taw_list, chi_dict=chi_dictionary, outpath=outpath,
                              name=amf_name, num_obs=dof, name_extension=name_ext)

print 'chi min dictionary \n', chimin_dict
